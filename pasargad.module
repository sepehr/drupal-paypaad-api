<?php
// $Id$

/**
 * @file
 * Contains Pasargad Bank Payment API implementations and helpers.
 */

/**
 * Defines API version.
 */
define('PASARGAD_API_VERSION', 2);

/**
 * Defines gateway default transaction trace URI.
 */
define('PASARGAD_TRACE_URI', 'https://paypaad.bankpasargad.com/PaymentTrace');

/**
 * Defines gateway default controller URI.
 */
define('PASARGAD_CONTROLLER_URI', 'https://paypaad.bankpasargad.com/PaymentController');

/**
 * API function to create invoice content's XML representation.
 *
 * @param $content
 *   An array of required content items as per defined in gateway docs, v2.
 *   - time_stamp: Request date in PHP's "Y/m/d H:i:s" format. (optional)
 *   - invoice_date: Invoice date in an optional format. (optional)
 *   - invoice_number: Invoice number.
 *   - merchant_code: Store merchant code as per provided by Pasargad Bank.
 *   - terminal_code: Store terminal code as per provided by Pasargad Bank.
 *   - redirect_address: Operation success URL.
 *   - referer_address: Operation failure URL.
 *   - delivery_days: Number of days in which the products will be delivered.
 *   - total_amount: Order total amount.
 *   - buyer_name: Customer name.
 *   - buyer_tel: Customer contact tel.
 *   - delivery_address: Products delivery address.
 * @param $items
 *   An array of product arrays/objects or a single product array/object,
 *   which will be injected into $content array as per defined in docs, v2.
 *   - content: Product title.
 *   - count: Number of purchased products.
 *   - fee: Price of product unit.
 *   - amount: fee x count amount.
 *   - description: Product description.
 *
 * @return
 *   XML representation of passed arguments or FALSE on fail.$items
 *
 * @see _pasargad_xml_build()
 * @see http://developers.paypaad.ir/docs/readme.pdf
 */
function pasargad_xml(&$content, $items = array()) {
  // Not enough minerals?!
  if (count($content) < 10) {
    return FALSE;
  }
  // Default value for time_stamp, if not set.
  $content['time_stamp'] = $content['time_stamp'] ? $content['time_stamp'] : date('Y/m/d H:i:s');
  // Default value for invoice_date, if not set.
  $content['invoice_date'] = $content['invoice_date'] ? $content['invoice_date'] : format_date(time());
  // Wrap a single product array/object to be prepared to be built.
  if (!empty($items) && (is_object($items) || !is_array($items[0]))) {
    $items = array($items);
  }
  // Build and return.
  return _pasargad_xml_build($content, $items);
}

/**
 * API function that signs XML representation of content.
 *
 * @param $xml
 *   Valid XML representation of content as per defined in docs, v2.
 * @param $private
 *   Private key as per required by openssl_pkey_get_private().
 * @param $passphrase
 *   Private key passphrase in case that the $private is encrypted.
 * @param $public
 *   Optional public key as per required by openssl_verify(),
 *   if set, generated signature will be passed through openssl_verify() to
 *   get verified. Note that $public format differs from the $private one and
 *   should be a openssl_pkey_get_public() valid output or the operation fails.
 *   Am lazy, ya!
 *
 * @return
 *   Either signed XML content or FALSE on fail.
 *
 * @see pasargad_xml()
 * @see http://php.net/manual/en/book.openssl.php
 * @see http://developers.paypaad.ir/docs/readme.pdf
 */
function pasargad_sign($xml, $private, $passphrase = '', $public = FALSE) {
  // Fail if OpenSSL extension is not loaded.
  if (!extension_loaded('openssl')) {
    return FALSE;
  }

  // Get private key if possible.
  if ($private = openssl_pkey_get_private($private, $passphrase)) {
    $sign = '';
    // Generate the signature if possible.
    if (openssl_sign($xml, $sign, $private)) {
      // Verify the signature using public pair, if requested so.
      if (!$public || openssl_verify($xml, $sign, $public) === 1) {
        // Gateway requires a Base64 encoded string
        // of the generated signature, see docs v2, p3.
        return base64_encode($sign);
      }
    }
    // Free $private from memory.
    openssl_free_key($private);
  }
  // Operation failed.
  return FALSE;
}

/**
 * API function to request Pasargad Bank gateway.
 *
 * @param $gateway
 *   Pasargad Bank gateway controller URI.
 *
 * @return
 *   An array of request response.
 *
 * @see http://developers.paypaad.ir/docs/readme.pdf
 */
function pasargad_request($gateway = PASARGAD_CONTROLLER_URI) {

}

/**
 * API function to request Pasargad Bank gateway.
 *
 * @param $gateway
 *   Pasargad Bank gateway trace URI.
 *
 * @return
 *   An array of request response.
 *
 * @see http://developers.paypaad.ir/docs/readme.pdf
 */
function pasargad_trace($gateway = PASARGAD_TRACE_URI) {

}

/**
 * Internal helper to perform a cURL POST request.
 *
 * @param $destination
 *   cURL destination URI.
 * @param $params
 *   Parameters to be sent in a HTTP POST operation,
 *   As per defined in CURLOPT_POSTFIELDS docs.
 *
 * @return
 *   Either the request response or FALSE on fail.
 *
 * @see pasargad_trace()
 * @see pasargad_request()
 * @see http://php.net/manual/en/function.curl-setopt.php
 */
function _pasargard_curl($destination, $params = '') {
  // cURL is a dependency.
  if (!extension_loaded('curl')) {
    return FALSE;
  }

  // Initiate cURL session, set options.
  $curl = curl_init();
  curl_setopt($curl, CURLOPT_URL, $destination);
  curl_setopt($curl, CURLOPT_HEADER, FALSE);
  curl_setopt($curl, CURLOPT_FAILONERROR, TRUE);
  curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);
  // Follow any 'Location:' header,
  // CURLOPT_MAXREDIRS won't be set.
  curl_setopt($curl, CURLOPT_FOLLOWLOCATION, TRUE);
  // Set POST request options.
  curl_setopt($curl, CURLOPT_POST, TRUE);
  curl_setopt($curl, CURLOPT_POSTFIELDS, $params);
  // Run rabbit, run!
  $response = curl_exec($curl);

  // Close the session & return the response.
  curl_close($curl);
  return (string) $response;
}

/**
 * Internal helper to build XML string as per required by gateway.
 *
 * @param $content
 *   Invoice array as per documented in pasargad_xml().
 * @param $items
 *   Products array as per documented in pasargad_xml().
 * @param $validate
 *   Whether to validate the generated XML using gateway
 *   provided DTD or not.
 *
 * @return
 *   $array corresponding XML.
 *
 * @see pasargad_xml()
 * @see _pasargad_xml_validate()
 * @see _pasargad_xml_template_load()
 */
function _pasargad_xml_build(&$content, &$items, $validate = FALSE) {
  // XML document header.
  $xml = '<?xml version="1.0" encoding="UTF-8" ?>';
  // In case of empty $items, remove %items% placeholder.
  $content['items'] = '';
  // Walk through the products array.
  if (!empty($items)) {
    $count = 1;
    foreach ($items as $index => $product) {
      $content['items'] .= _pasargad_xml_template_load((array) $product, 'item');
    }
  }
  // Build invoice XML body.
  $xml .= _pasargad_xml_template_load($content, 'invoice');

  // Validate generated XML against its DTD, if requested so.
  if ($validate) {
    return _pasargad_xml_validate($xml) ? $xml : FALSE;
  }
  return $xml;
}

/**
 * Internal helper that loads a XML template with given data.
 *
 * @param $data
 *   An array of keyed values to be used as a dictionary.
 *   e.g. Every %blah% placeholder in $template will be filled
 *   with the value of 'blah' key in the $data array.
 * @param $template
 *   XML template identifier to load its string with $data.
 *   Accepted values are as per documented in _pasargad_xml_template().
 * @param $eol_strip
 *   Whether to strip OS EOL chars or not.
 *
 * @return
 *   Either the requested XML template or FALSE on fail.
 *
 * @see _pasargad_xml_build()
 * @see _pasargad_xml_template()
 */
function _pasargad_xml_template_load($data, $template, $eol_strip = TRUE) {
  // Get XML template string.
  $template = _pasargad_xml_template($template, $eol_strip);
  // Not enough minerals?!
  if (!$data || !$template) {
    return FALSE;
  }
  // Walk through the array.
  foreach ($data as $key => $value) {
    $template = str_replace("%$key%", $value, $template);
  }
  return $template;
}

/**
 * Internal static cache helper that returns a XML template.
 *
 * Avoids API change maintenance disasters!
 *
 * @param $id
 *   XML template identifier to return.
 *   - invoice: returns invoice XML template.
 *   - item: returns an item XML template. (product)
 * @param $eol_strip
 *   Whether to strip OS EOL chars or not.
 *
 * @return
 *   Either the requested XML template or FALSE on fail.
 *
 * @see _pasargad_xml_build()
 */
function _pasargad_xml_template($id, $eol_strip = TRUE) {
  static $templates = array();

  // Implementing static cache.
  if (!$templates[$id]) {
    // Get requested XML template path.
    $path = drupal_get_path('module', 'pasargad') . "/xml/$id.tpl.xml";
    // Check if the XML template file is readable.
    if (is_readable($path)) {
      $templates[$id] = file_get_contents($path);
    }
    else {
      return FALSE;
    }
  }
  // Return XML template string as requested.
  return $eol_strip ? str_replace(array("\r", "\n"), '', $templates[$id]) : $templates[$id];
}

/**
 * Internal helper that validates a XML string against given DTD.
 *
 * @param $xml
 *   XML string to be validated.
 * @param $root
 *   XML root node name.
 * @param $dtd_path
 *   Accessible system path of DTD file.
 *
 * @return
 *   Boolean value.
 *
 * @see http://php.net/manual/en/class.domdocument.php
 * @see http://us.php.net/manual/en/domdocument.schemavalidate.php
 *
 * @todo
 *   If possible, generate appropriate XSD file and
 *   validate against that using DOMDocument::schemaValidate.
 */
function _pasargad_xml_validate($xml, $root = 'invoice', $dtd_path = FALSE) {
  // Check DTD file path.
  $dtd_path = $dtd_path ? $dtd_path : drupal_get_path('module', 'pasargad') . '/xml/protocol.dtd';
  if (!is_readable($dtd_path)) {
    return FALSE;
  }

  // Return XML validation results:
  // Here we should use a trick and
  // then validation will be simply done.
  // DTD is pretty damn old, XSD might be a
  // better choice here.
  //
  // Instantiate a DOMDocument object based
  // on passed XML string, if the $xml string
  // has its own DTD included, overwrite that
  // with the one specified in $dtd_path file.
  $DOMDoc = new DOMDocument();
  $DOMDoc->loadXML($xml);
  // Instantiate a new DOMDocument with $dtd_path DTD.
  $DOMCreator = new DOMImplementation();
  $DOMDocType = $DOMCreator->createDocumentType($root, NULL, $dtd_path);
  $NewDOMDoc  = $DOMCreator->createDocument(NULL, NULL, $DOMDocType);
  $NewDOMDoc->encoding = 'UTF-8';
  // Loading $xml directly into the new object will
  // cause $NewDOMDoc's DTD ($dtd_path) to be overwritten
  // by the original DTD specified in passed XML string.
  $DOMDocNode = $DOMDoc->getElementsByTagName($root)->item(0);
  $NewDOMDocNode = $NewDOMDoc->importNode($DOMDocNode, TRUE);
  $NewDOMDoc->appendChild($NewDOMDocNode);
  // Validate and return results.
  return $NewDOMDoc->validate();
}

